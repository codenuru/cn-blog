### This file was generated by Nexus Schema
### Do not make changes to this file directly


type AuthPayload {
  error: String
  token: String
  user: User
}

type BatchPayload {
  count: Int
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

type Category {
  id: Int!
  name: String!
  post: Post
  postId: Int
  slug: String!
}

input CategoryCreateInput {
  name: String!
  post: PostCreateOneWithoutCategoriesInput!
  slug: String!
}

input CategoryCreateManyWithoutPostInput {
  connect: [CategoryWhereUniqueInput!]
  create: [CategoryCreateWithoutPostInput!]
}

input CategoryCreateWithoutPostInput {
  name: String!
  slug: String!
}

input CategoryListRelationFilter {
  every: CategoryWhereInput
  none: CategoryWhereInput
  some: CategoryWhereInput
}

input CategoryOrderByInput {
  id: SortOrder
  name: SortOrder
  postId: SortOrder
  slug: SortOrder
}

input CategoryScalarWhereInput {
  AND: [CategoryScalarWhereInput!]
  id: IntFilter
  name: StringFilter
  NOT: [CategoryScalarWhereInput!]
  OR: [CategoryScalarWhereInput!]
  postId: IntFilter
  slug: StringFilter
}

input CategoryUpdateInput {
  name: StringFieldUpdateOperationsInput
  post: PostUpdateOneRequiredWithoutCategoriesInput
  slug: StringFieldUpdateOperationsInput
}

input CategoryUpdateManyDataInput {
  name: StringFieldUpdateOperationsInput
  slug: StringFieldUpdateOperationsInput
}

input CategoryUpdateManyMutationInput {
  name: StringFieldUpdateOperationsInput
  slug: StringFieldUpdateOperationsInput
}

input CategoryUpdateManyWithoutPostInput {
  connect: [CategoryWhereUniqueInput!]
  create: [CategoryCreateWithoutPostInput!]
  delete: [CategoryWhereUniqueInput!]
  deleteMany: [CategoryScalarWhereInput!]
  disconnect: [CategoryWhereUniqueInput!]
  set: [CategoryWhereUniqueInput!]
  update: [CategoryUpdateWithWhereUniqueWithoutPostInput!]
  updateMany: [CategoryUpdateManyWithWhereNestedInput!]
  upsert: [CategoryUpsertWithWhereUniqueWithoutPostInput!]
}

input CategoryUpdateManyWithWhereNestedInput {
  data: CategoryUpdateManyDataInput!
  where: CategoryScalarWhereInput!
}

input CategoryUpdateWithoutPostDataInput {
  name: StringFieldUpdateOperationsInput
  slug: StringFieldUpdateOperationsInput
}

input CategoryUpdateWithWhereUniqueWithoutPostInput {
  data: CategoryUpdateWithoutPostDataInput!
  where: CategoryWhereUniqueInput!
}

input CategoryUpsertWithWhereUniqueWithoutPostInput {
  create: CategoryCreateWithoutPostInput!
  update: CategoryUpdateWithoutPostDataInput!
  where: CategoryWhereUniqueInput!
}

input CategoryWhereInput {
  AND: [CategoryWhereInput!]
  id: IntFilter
  name: StringFilter
  NOT: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  post: PostWhereInput
  postId: IntFilter
  slug: StringFilter
}

input CategoryWhereUniqueInput {
  id: Int
  name: String
  slug: String
}

type Comment {
  author: User
  authorId: Int
  contain: String!
  createdAt: DateTime!
  id: Int!
  post: Post!
  postId: Int
  updatedAt: DateTime!
}

input CommentCreateInput {
  author: UserCreateOneWithoutCommentsInput
  contain: String!
  createdAt: DateTime
  post: PostCreateOneWithoutCommentsInput!
  updatedAt: DateTime
}

input CommentCreateManyWithoutAuthorInput {
  connect: [CommentWhereUniqueInput!]
  create: [CommentCreateWithoutAuthorInput!]
}

input CommentCreateManyWithoutPostInput {
  connect: [CommentWhereUniqueInput!]
  create: [CommentCreateWithoutPostInput!]
}

input CommentCreateWithoutAuthorInput {
  contain: String!
  createdAt: DateTime
  post: PostCreateOneWithoutCommentsInput!
  updatedAt: DateTime
}

input CommentCreateWithoutPostInput {
  author: UserCreateOneWithoutCommentsInput
  contain: String!
  createdAt: DateTime
  updatedAt: DateTime
}

input CommentListRelationFilter {
  every: CommentWhereInput
  none: CommentWhereInput
  some: CommentWhereInput
}

input CommentOrderByInput {
  authorId: SortOrder
  contain: SortOrder
  createdAt: SortOrder
  id: SortOrder
  postId: SortOrder
  updatedAt: SortOrder
}

input CommentScalarWhereInput {
  AND: [CommentScalarWhereInput!]
  authorId: IntNullableFilter
  contain: StringFilter
  createdAt: DateTimeFilter
  id: IntFilter
  NOT: [CommentScalarWhereInput!]
  OR: [CommentScalarWhereInput!]
  postId: IntFilter
  updatedAt: DateTimeFilter
}

input CommentUpdateInput {
  author: UserUpdateOneWithoutCommentsInput
  contain: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  post: PostUpdateOneRequiredWithoutCommentsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CommentUpdateManyDataInput {
  contain: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CommentUpdateManyMutationInput {
  contain: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CommentUpdateManyWithoutAuthorInput {
  connect: [CommentWhereUniqueInput!]
  create: [CommentCreateWithoutAuthorInput!]
  delete: [CommentWhereUniqueInput!]
  deleteMany: [CommentScalarWhereInput!]
  disconnect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutAuthorInput!]
}

input CommentUpdateManyWithoutPostInput {
  connect: [CommentWhereUniqueInput!]
  create: [CommentCreateWithoutPostInput!]
  delete: [CommentWhereUniqueInput!]
  deleteMany: [CommentScalarWhereInput!]
  disconnect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutPostInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutPostInput!]
}

input CommentUpdateManyWithWhereNestedInput {
  data: CommentUpdateManyDataInput!
  where: CommentScalarWhereInput!
}

input CommentUpdateWithoutAuthorDataInput {
  contain: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  post: PostUpdateOneRequiredWithoutCommentsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CommentUpdateWithoutPostDataInput {
  author: UserUpdateOneWithoutCommentsInput
  contain: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CommentUpdateWithWhereUniqueWithoutAuthorInput {
  data: CommentUpdateWithoutAuthorDataInput!
  where: CommentWhereUniqueInput!
}

input CommentUpdateWithWhereUniqueWithoutPostInput {
  data: CommentUpdateWithoutPostDataInput!
  where: CommentWhereUniqueInput!
}

input CommentUpsertWithWhereUniqueWithoutAuthorInput {
  create: CommentCreateWithoutAuthorInput!
  update: CommentUpdateWithoutAuthorDataInput!
  where: CommentWhereUniqueInput!
}

input CommentUpsertWithWhereUniqueWithoutPostInput {
  create: CommentCreateWithoutPostInput!
  update: CommentUpdateWithoutPostDataInput!
  where: CommentWhereUniqueInput!
}

input CommentWhereInput {
  AND: [CommentWhereInput!]
  author: UserWhereInput
  authorId: IntNullableFilter
  contain: StringFilter
  createdAt: DateTimeFilter
  id: IntFilter
  NOT: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  post: PostWhereInput
  postId: IntFilter
  updatedAt: DateTimeFilter
}

input CommentWhereUniqueInput {
  id: Int
}

"""
A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar Date

scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input EnumRoleFieldUpdateOperationsInput {
  set: Role
}

input EnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input IntFieldUpdateOperationsInput {
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

type Mutation {
  changePassword(newPassword: String!, oldPassword: String!): User
  createOneCategory(data: CategoryCreateInput!): Category!
  createOneComment(data: CommentCreateInput!): Comment!
  createOnePost(data: PostCreateInput!): Post!
  createOneTag(data: TagCreateInput!): Tag!
  createOneUser(data: UserCreateInput!): User!
  deleteManyCategory(where: CategoryWhereInput): BatchPayload
  deleteManyComment(where: CommentWhereInput): BatchPayload
  deleteManyPost(where: PostWhereInput): BatchPayload
  deleteManyTag(where: TagWhereInput): BatchPayload
  deleteManyUser(where: UserWhereInput): BatchPayload
  deleteOneCategory(where: CategoryWhereUniqueInput!): Category
  deleteOneComment(where: CommentWhereUniqueInput!): Comment
  deleteOnePost(where: PostWhereUniqueInput!): Post
  deleteOneTag(where: TagWhereUniqueInput!): Tag
  deleteOneUser(where: UserWhereUniqueInput!): User
  updateManyCategory(data: CategoryUpdateManyMutationInput!, where: CategoryWhereInput): BatchPayload
  updateManyComment(data: CommentUpdateManyMutationInput!, where: CommentWhereInput): BatchPayload
  updateManyPost(data: PostUpdateManyMutationInput!, where: PostWhereInput): BatchPayload
  updateManyTag(data: TagUpdateManyMutationInput!, where: TagWhereInput): BatchPayload
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload
  updateOneCategory(data: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category!
  updateOneComment(data: CommentUpdateInput!, where: CommentWhereUniqueInput!): Comment!
  updateOnePost(data: PostUpdateInput!, where: PostWhereUniqueInput!): Post!
  updateOneTag(data: TagUpdateInput!, where: TagWhereUniqueInput!): Tag!
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User!
  upsertOneCategory(create: CategoryCreateInput!, update: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category!
  upsertOneComment(create: CommentCreateInput!, update: CommentUpdateInput!, where: CommentWhereUniqueInput!): Comment!
  upsertOnePost(create: PostCreateInput!, update: PostUpdateInput!, where: PostWhereUniqueInput!): Post!
  upsertOneTag(create: TagCreateInput!, update: TagUpdateInput!, where: TagWhereUniqueInput!): Tag!
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!

  """Login mutation: Send your email and password then get back a token"""
  userLogin(
    """email of the user"""
    email: String!

    """password of the user"""
    password: String!
  ): AuthPayload

  """
  Call this mutation to sign a new user up. It will return a auth payload
  """
  userSignup(email: String!, name: String, password: String!, surname: String): AuthPayload
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedEnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Post {
  author: User!
  authorId: Int!
  categories: [Category!]
  comments(cursor: CommentWhereUniqueInput, orderBy: CommentOrderByInput, skip: Int, take: Int, where: CommentWhereInput): [Comment!]
  content: String
  createdAt: DateTime!
  id: Int!
  likeCount: Int
  published: Boolean!
  tags: [Tag!]
  title: String
  updatedAt: DateTime!
  viewCount: Int
}

input PostCreateInput {
  author: UserCreateOneWithoutPostsInput
  categories: CategoryCreateManyWithoutPostInput
  comments: CommentCreateManyWithoutPostInput
  content: String
  createdAt: DateTime
  likeCount: Int
  published: Boolean
  tags: TagCreateManyWithoutPostInput
  title: String!
  updatedAt: DateTime
  viewCount: Int
}

input PostCreateManyWithoutAuthorInput {
  connect: [PostWhereUniqueInput!]
  create: [PostCreateWithoutAuthorInput!]
}

input PostCreateOneWithoutCategoriesInput {
  connect: PostWhereUniqueInput
  create: PostCreateWithoutCategoriesInput
}

input PostCreateOneWithoutCommentsInput {
  connect: PostWhereUniqueInput
  create: PostCreateWithoutCommentsInput
}

input PostCreateOneWithoutTagsInput {
  connect: PostWhereUniqueInput
  create: PostCreateWithoutTagsInput
}

input PostCreateWithoutAuthorInput {
  categories: CategoryCreateManyWithoutPostInput
  comments: CommentCreateManyWithoutPostInput
  content: String
  createdAt: DateTime
  likeCount: Int
  published: Boolean
  tags: TagCreateManyWithoutPostInput
  title: String!
  updatedAt: DateTime
  viewCount: Int
}

input PostCreateWithoutCategoriesInput {
  author: UserCreateOneWithoutPostsInput
  comments: CommentCreateManyWithoutPostInput
  content: String
  createdAt: DateTime
  likeCount: Int
  published: Boolean
  tags: TagCreateManyWithoutPostInput
  title: String!
  updatedAt: DateTime
  viewCount: Int
}

input PostCreateWithoutCommentsInput {
  author: UserCreateOneWithoutPostsInput
  categories: CategoryCreateManyWithoutPostInput
  content: String
  createdAt: DateTime
  likeCount: Int
  published: Boolean
  tags: TagCreateManyWithoutPostInput
  title: String!
  updatedAt: DateTime
  viewCount: Int
}

input PostCreateWithoutTagsInput {
  author: UserCreateOneWithoutPostsInput
  categories: CategoryCreateManyWithoutPostInput
  comments: CommentCreateManyWithoutPostInput
  content: String
  createdAt: DateTime
  likeCount: Int
  published: Boolean
  title: String!
  updatedAt: DateTime
  viewCount: Int
}

input PostListRelationFilter {
  every: PostWhereInput
  none: PostWhereInput
  some: PostWhereInput
}

input PostOrderByInput {
  authorId: SortOrder
  content: SortOrder
  createdAt: SortOrder
  id: SortOrder
  likeCount: SortOrder
  published: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  viewCount: SortOrder
}

input PostScalarWhereInput {
  AND: [PostScalarWhereInput!]
  authorId: IntNullableFilter
  content: StringNullableFilter
  createdAt: DateTimeFilter
  id: IntFilter
  likeCount: IntFilter
  NOT: [PostScalarWhereInput!]
  OR: [PostScalarWhereInput!]
  published: BoolFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  viewCount: IntFilter
}

input PostUpdateInput {
  author: UserUpdateOneWithoutPostsInput
  categories: CategoryUpdateManyWithoutPostInput
  comments: CommentUpdateManyWithoutPostInput
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  likeCount: IntFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  tags: TagUpdateManyWithoutPostInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  viewCount: IntFieldUpdateOperationsInput
}

input PostUpdateManyDataInput {
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  likeCount: IntFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  viewCount: IntFieldUpdateOperationsInput
}

input PostUpdateManyMutationInput {
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  likeCount: IntFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  viewCount: IntFieldUpdateOperationsInput
}

input PostUpdateManyWithoutAuthorInput {
  connect: [PostWhereUniqueInput!]
  create: [PostCreateWithoutAuthorInput!]
  delete: [PostWhereUniqueInput!]
  deleteMany: [PostScalarWhereInput!]
  disconnect: [PostWhereUniqueInput!]
  set: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [PostUpdateManyWithWhereNestedInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutAuthorInput!]
}

input PostUpdateManyWithWhereNestedInput {
  data: PostUpdateManyDataInput!
  where: PostScalarWhereInput!
}

input PostUpdateOneRequiredWithoutCategoriesInput {
  connect: PostWhereUniqueInput
  create: PostCreateWithoutCategoriesInput
  update: PostUpdateWithoutCategoriesDataInput
  upsert: PostUpsertWithoutCategoriesInput
}

input PostUpdateOneRequiredWithoutCommentsInput {
  connect: PostWhereUniqueInput
  create: PostCreateWithoutCommentsInput
  update: PostUpdateWithoutCommentsDataInput
  upsert: PostUpsertWithoutCommentsInput
}

input PostUpdateOneRequiredWithoutTagsInput {
  connect: PostWhereUniqueInput
  create: PostCreateWithoutTagsInput
  update: PostUpdateWithoutTagsDataInput
  upsert: PostUpsertWithoutTagsInput
}

input PostUpdateWithoutAuthorDataInput {
  categories: CategoryUpdateManyWithoutPostInput
  comments: CommentUpdateManyWithoutPostInput
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  likeCount: IntFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  tags: TagUpdateManyWithoutPostInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  viewCount: IntFieldUpdateOperationsInput
}

input PostUpdateWithoutCategoriesDataInput {
  author: UserUpdateOneWithoutPostsInput
  comments: CommentUpdateManyWithoutPostInput
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  likeCount: IntFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  tags: TagUpdateManyWithoutPostInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  viewCount: IntFieldUpdateOperationsInput
}

input PostUpdateWithoutCommentsDataInput {
  author: UserUpdateOneWithoutPostsInput
  categories: CategoryUpdateManyWithoutPostInput
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  likeCount: IntFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  tags: TagUpdateManyWithoutPostInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  viewCount: IntFieldUpdateOperationsInput
}

input PostUpdateWithoutTagsDataInput {
  author: UserUpdateOneWithoutPostsInput
  categories: CategoryUpdateManyWithoutPostInput
  comments: CommentUpdateManyWithoutPostInput
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  likeCount: IntFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  viewCount: IntFieldUpdateOperationsInput
}

input PostUpdateWithWhereUniqueWithoutAuthorInput {
  data: PostUpdateWithoutAuthorDataInput!
  where: PostWhereUniqueInput!
}

input PostUpsertWithoutCategoriesInput {
  create: PostCreateWithoutCategoriesInput!
  update: PostUpdateWithoutCategoriesDataInput!
}

input PostUpsertWithoutCommentsInput {
  create: PostCreateWithoutCommentsInput!
  update: PostUpdateWithoutCommentsDataInput!
}

input PostUpsertWithoutTagsInput {
  create: PostCreateWithoutTagsInput!
  update: PostUpdateWithoutTagsDataInput!
}

input PostUpsertWithWhereUniqueWithoutAuthorInput {
  create: PostCreateWithoutAuthorInput!
  update: PostUpdateWithoutAuthorDataInput!
  where: PostWhereUniqueInput!
}

input PostWhereInput {
  AND: [PostWhereInput!]
  author: UserWhereInput
  authorId: IntNullableFilter
  categories: CategoryListRelationFilter
  comments: CommentListRelationFilter
  content: StringNullableFilter
  createdAt: DateTimeFilter
  id: IntFilter
  likeCount: IntFilter
  NOT: [PostWhereInput!]
  OR: [PostWhereInput!]
  published: BoolFilter
  tags: TagListRelationFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  viewCount: IntFilter
}

input PostWhereUniqueInput {
  id: Int
}

type Query {
  categories(after: CategoryWhereUniqueInput, before: CategoryWhereUniqueInput, first: Int, last: Int, orderBy: [CategoryOrderByInput!], where: CategoryWhereInput): [Category!]!
  comments(after: CommentWhereUniqueInput, before: CommentWhereUniqueInput, first: Int, last: Int, orderBy: [CommentOrderByInput!], where: CommentWhereInput): [Comment!]!
  findManyComment(cursor: CommentWhereUniqueInput, orderBy: CommentOrderByInput, skip: Int, take: Int, where: CommentWhereInput): [Comment]
  findManyCommentCount(cursor: CommentWhereUniqueInput, orderBy: CommentOrderByInput, skip: Int, take: Int, where: CommentWhereInput): Int
  findManyPost(cursor: PostWhereUniqueInput, orderBy: PostOrderByInput, skip: Int, take: Int, where: PostWhereInput): [Post]
  findManyPostCount(cursor: PostWhereUniqueInput, orderBy: PostOrderByInput, skip: Int, take: Int, where: PostWhereInput): Int
  findManyUser(cursor: UserWhereUniqueInput, orderBy: UserOrderByInput, skip: Int, take: Int, where: UserWhereInput): [User]
  findManyUserCount(cursor: UserWhereUniqueInput, orderBy: UserOrderByInput, skip: Int, take: Int, where: UserWhereInput): Int
  findOneComment(where: CommentWhereUniqueInput!): Comment
  findOnePost(where: PostWhereUniqueInput!): Post
  findOneUser(where: UserWhereUniqueInput!): User

  """The current authenticated User"""
  me: User
  posts(after: PostWhereUniqueInput, before: PostWhereUniqueInput, first: Int, last: Int, orderBy: [PostOrderByInput!], where: PostWhereInput): [Post!]!
  tags(after: TagWhereUniqueInput, before: TagWhereUniqueInput, first: Int, last: Int, orderBy: [TagOrderByInput!], where: TagWhereInput): [Tag!]!
  users(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int, orderBy: [UserOrderByInput!], where: UserWhereInput): [User!]!
}

enum QueryMode {
  default
  insensitive
}

enum Role {
  ADMIN
  SUPER_USER
  USER
}

"""User Role"""
enum RoleEnum {
  ADMIN
  SUPER_USER
  USER
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type Tag {
  id: Int!
  name: String!
  post: Post
  postId: Int
  slug: String!
}

input TagCreateInput {
  name: String!
  post: PostCreateOneWithoutTagsInput!
  slug: String!
}

input TagCreateManyWithoutPostInput {
  connect: [TagWhereUniqueInput!]
  create: [TagCreateWithoutPostInput!]
}

input TagCreateWithoutPostInput {
  name: String!
  slug: String!
}

input TagListRelationFilter {
  every: TagWhereInput
  none: TagWhereInput
  some: TagWhereInput
}

input TagOrderByInput {
  id: SortOrder
  name: SortOrder
  postId: SortOrder
  slug: SortOrder
}

input TagScalarWhereInput {
  AND: [TagScalarWhereInput!]
  id: IntFilter
  name: StringFilter
  NOT: [TagScalarWhereInput!]
  OR: [TagScalarWhereInput!]
  postId: IntFilter
  slug: StringFilter
}

input TagUpdateInput {
  name: StringFieldUpdateOperationsInput
  post: PostUpdateOneRequiredWithoutTagsInput
  slug: StringFieldUpdateOperationsInput
}

input TagUpdateManyDataInput {
  name: StringFieldUpdateOperationsInput
  slug: StringFieldUpdateOperationsInput
}

input TagUpdateManyMutationInput {
  name: StringFieldUpdateOperationsInput
  slug: StringFieldUpdateOperationsInput
}

input TagUpdateManyWithoutPostInput {
  connect: [TagWhereUniqueInput!]
  create: [TagCreateWithoutPostInput!]
  delete: [TagWhereUniqueInput!]
  deleteMany: [TagScalarWhereInput!]
  disconnect: [TagWhereUniqueInput!]
  set: [TagWhereUniqueInput!]
  update: [TagUpdateWithWhereUniqueWithoutPostInput!]
  updateMany: [TagUpdateManyWithWhereNestedInput!]
  upsert: [TagUpsertWithWhereUniqueWithoutPostInput!]
}

input TagUpdateManyWithWhereNestedInput {
  data: TagUpdateManyDataInput!
  where: TagScalarWhereInput!
}

input TagUpdateWithoutPostDataInput {
  name: StringFieldUpdateOperationsInput
  slug: StringFieldUpdateOperationsInput
}

input TagUpdateWithWhereUniqueWithoutPostInput {
  data: TagUpdateWithoutPostDataInput!
  where: TagWhereUniqueInput!
}

input TagUpsertWithWhereUniqueWithoutPostInput {
  create: TagCreateWithoutPostInput!
  update: TagUpdateWithoutPostDataInput!
  where: TagWhereUniqueInput!
}

input TagWhereInput {
  AND: [TagWhereInput!]
  id: IntFilter
  name: StringFilter
  NOT: [TagWhereInput!]
  OR: [TagWhereInput!]
  post: PostWhereInput
  postId: IntFilter
  slug: StringFilter
}

input TagWhereUniqueInput {
  id: Int
  name: String
  slug: String
}

"""A user registered with the application"""
type User {
  comments(cursor: CommentWhereUniqueInput, orderBy: CommentOrderByInput, skip: Int, take: Int, where: CommentWhereInput): [Comment!]!
  createdAt: DateTime!
  email: String!
  fullName: String
  id: Int!
  isDeleted: Boolean!
  name: String!
  password: String!
  posts(cursor: PostWhereUniqueInput, orderBy: PostOrderByInput, skip: Int, take: Int, where: PostWhereInput): [Post!]!
  role: RoleEnum
  surname: String!
}

input UserCreateInput {
  comments: CommentCreateManyWithoutAuthorInput
  createdAt: DateTime
  email: String!
  isDeleted: Boolean
  name: String!
  password: String!
  posts: PostCreateManyWithoutAuthorInput
  role: Role
  surname: String!
}

input UserCreateOneWithoutCommentsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutCommentsInput
}

input UserCreateOneWithoutPostsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutPostsInput
}

input UserCreateWithoutCommentsInput {
  createdAt: DateTime
  email: String!
  isDeleted: Boolean
  name: String!
  password: String!
  posts: PostCreateManyWithoutAuthorInput
  role: Role
  surname: String!
}

input UserCreateWithoutPostsInput {
  comments: CommentCreateManyWithoutAuthorInput
  createdAt: DateTime
  email: String!
  isDeleted: Boolean
  name: String!
  password: String!
  role: Role
  surname: String!
}

input UserOrderByInput {
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  isDeleted: SortOrder
  name: SortOrder
  password: SortOrder
  role: SortOrder
  surname: SortOrder
}

input UserUpdateInput {
  comments: CommentUpdateManyWithoutAuthorInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  isDeleted: BoolFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  posts: PostUpdateManyWithoutAuthorInput
  role: EnumRoleFieldUpdateOperationsInput
  surname: StringFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  isDeleted: BoolFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  surname: StringFieldUpdateOperationsInput
}

input UserUpdateOneWithoutCommentsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutCommentsInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutCommentsDataInput
  upsert: UserUpsertWithoutCommentsInput
}

input UserUpdateOneWithoutPostsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutPostsInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutPostsDataInput
  upsert: UserUpsertWithoutPostsInput
}

input UserUpdateWithoutCommentsDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  isDeleted: BoolFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  posts: PostUpdateManyWithoutAuthorInput
  role: EnumRoleFieldUpdateOperationsInput
  surname: StringFieldUpdateOperationsInput
}

input UserUpdateWithoutPostsDataInput {
  comments: CommentUpdateManyWithoutAuthorInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  isDeleted: BoolFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  surname: StringFieldUpdateOperationsInput
}

input UserUpsertWithoutCommentsInput {
  create: UserCreateWithoutCommentsInput!
  update: UserUpdateWithoutCommentsDataInput!
}

input UserUpsertWithoutPostsInput {
  create: UserCreateWithoutPostsInput!
  update: UserUpdateWithoutPostsDataInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  comments: CommentListRelationFilter
  createdAt: DateTimeFilter
  email: StringFilter
  id: IntFilter
  isDeleted: BoolFilter
  name: StringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: StringFilter
  posts: PostListRelationFilter
  role: EnumRoleFilter
  surname: StringFilter
}

input UserWhereUniqueInput {
  email: String
  id: Int
}

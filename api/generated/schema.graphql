### This file was generated by Nexus Schema
### Do not make changes to this file directly


type AuthPayload {
  error: String
  token: String
  user: User
}

type BatchPayload {
  count: Int
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

type Comment {
  author: User
  authorId: Int
  contain: String!
  createdAt: DateTime!
  id: Int!
  post: Post!
  postId: Int
  updatedAt: DateTime!
}

input CommentCreateInput {
  author: UserCreateOneWithoutCommentsInput
  contain: String!
  createdAt: DateTime
  post: PostCreateOneWithoutCommentsInput!
  updatedAt: DateTime
}

input CommentCreateManyWithoutAuthorInput {
  connect: [CommentWhereUniqueInput!]
  create: [CommentCreateWithoutAuthorInput!]
}

input CommentCreateManyWithoutPostInput {
  connect: [CommentWhereUniqueInput!]
  create: [CommentCreateWithoutPostInput!]
}

input CommentCreateWithoutAuthorInput {
  contain: String!
  createdAt: DateTime
  post: PostCreateOneWithoutCommentsInput!
  updatedAt: DateTime
}

input CommentCreateWithoutPostInput {
  author: UserCreateOneWithoutCommentsInput
  contain: String!
  createdAt: DateTime
  updatedAt: DateTime
}

input CommentListRelationFilter {
  every: CommentWhereInput
  none: CommentWhereInput
  some: CommentWhereInput
}

input CommentOrderByInput {
  authorId: SortOrder
  contain: SortOrder
  createdAt: SortOrder
  id: SortOrder
  postId: SortOrder
  updatedAt: SortOrder
}

input CommentScalarWhereInput {
  AND: [CommentScalarWhereInput!]
  authorId: IntNullableFilter
  contain: StringFilter
  createdAt: DateTimeFilter
  id: IntFilter
  NOT: [CommentScalarWhereInput!]
  OR: [CommentScalarWhereInput!]
  postId: IntFilter
  updatedAt: DateTimeFilter
}

input CommentUpdateInput {
  author: UserUpdateOneWithoutCommentsInput
  contain: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  post: PostUpdateOneRequiredWithoutCommentsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CommentUpdateManyDataInput {
  contain: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CommentUpdateManyMutationInput {
  contain: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CommentUpdateManyWithoutAuthorInput {
  connect: [CommentWhereUniqueInput!]
  create: [CommentCreateWithoutAuthorInput!]
  delete: [CommentWhereUniqueInput!]
  deleteMany: [CommentScalarWhereInput!]
  disconnect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutAuthorInput!]
}

input CommentUpdateManyWithoutPostInput {
  connect: [CommentWhereUniqueInput!]
  create: [CommentCreateWithoutPostInput!]
  delete: [CommentWhereUniqueInput!]
  deleteMany: [CommentScalarWhereInput!]
  disconnect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutPostInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutPostInput!]
}

input CommentUpdateManyWithWhereNestedInput {
  data: CommentUpdateManyDataInput!
  where: CommentScalarWhereInput!
}

input CommentUpdateWithoutAuthorDataInput {
  contain: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  post: PostUpdateOneRequiredWithoutCommentsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CommentUpdateWithoutPostDataInput {
  author: UserUpdateOneWithoutCommentsInput
  contain: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CommentUpdateWithWhereUniqueWithoutAuthorInput {
  data: CommentUpdateWithoutAuthorDataInput!
  where: CommentWhereUniqueInput!
}

input CommentUpdateWithWhereUniqueWithoutPostInput {
  data: CommentUpdateWithoutPostDataInput!
  where: CommentWhereUniqueInput!
}

input CommentUpsertWithWhereUniqueWithoutAuthorInput {
  create: CommentCreateWithoutAuthorInput!
  update: CommentUpdateWithoutAuthorDataInput!
  where: CommentWhereUniqueInput!
}

input CommentUpsertWithWhereUniqueWithoutPostInput {
  create: CommentCreateWithoutPostInput!
  update: CommentUpdateWithoutPostDataInput!
  where: CommentWhereUniqueInput!
}

input CommentWhereInput {
  AND: [CommentWhereInput!]
  author: UserWhereInput
  authorId: IntNullableFilter
  contain: StringFilter
  createdAt: DateTimeFilter
  id: IntFilter
  NOT: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  post: PostWhereInput
  postId: IntFilter
  updatedAt: DateTimeFilter
}

input CommentWhereUniqueInput {
  id: Int
}

"""
A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar Date

scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input EnumRoleFieldUpdateOperationsInput {
  set: Role
}

input EnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input IntFieldUpdateOperationsInput {
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

type Mutation {
  changePassword(newPassword: String!, oldPassword: String!): User
  createOneComment(data: CommentCreateInput!): Comment!
  createOnePost(data: PostCreateInput!): Post!
  createOneUser(data: UserCreateInput!): User!
  deleteManyComment(where: CommentWhereInput): BatchPayload
  deleteManyPost(where: PostWhereInput): BatchPayload
  deleteManyUser(where: UserWhereInput): BatchPayload
  deleteOneComment(where: CommentWhereUniqueInput!): Comment
  deleteOnePost(where: PostWhereUniqueInput!): Post
  deleteOneUser(where: UserWhereUniqueInput!): User
  updateManyComment(data: CommentUpdateManyMutationInput!, where: CommentWhereInput): BatchPayload
  updateManyPost(data: PostUpdateManyMutationInput!, where: PostWhereInput): BatchPayload
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload
  updateOneComment(data: CommentUpdateInput!, where: CommentWhereUniqueInput!): Comment!
  updateOnePost(data: PostUpdateInput!, where: PostWhereUniqueInput!): Post!
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User!
  upsertOneComment(create: CommentCreateInput!, update: CommentUpdateInput!, where: CommentWhereUniqueInput!): Comment!
  upsertOnePost(create: PostCreateInput!, update: PostUpdateInput!, where: PostWhereUniqueInput!): Post!
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!

  """Login mutation: Send your email and password then get back a token"""
  userLogin(
    """email of the user"""
    email: String!

    """password of the user"""
    password: String!
  ): AuthPayload

  """
  Call this mutation to sign a new user up. It will return a auth payload
  """
  userSignup(email: String!, name: String, password: String!, surname: String): AuthPayload
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedEnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Post {
  author: User
  authorId: Int
  comments(cursor: CommentWhereUniqueInput, orderBy: CommentOrderByInput, skip: Int, take: Int, where: CommentWhereInput): [Comment!]!
  content: String
  createdAt: DateTime!
  id: Int!
  published: Boolean!
  title: String
  updatedAt: DateTime!
  viewCount: Int
}

input PostCreateInput {
  author: UserCreateOneWithoutPostsInput
  comments: CommentCreateManyWithoutPostInput
  content: String
  createdAt: DateTime
  published: Boolean
  title: String!
  updatedAt: DateTime
  viewCount: Int
}

input PostCreateManyWithoutAuthorInput {
  connect: [PostWhereUniqueInput!]
  create: [PostCreateWithoutAuthorInput!]
}

input PostCreateOneWithoutCommentsInput {
  connect: PostWhereUniqueInput
  create: PostCreateWithoutCommentsInput
}

input PostCreateWithoutAuthorInput {
  comments: CommentCreateManyWithoutPostInput
  content: String
  createdAt: DateTime
  published: Boolean
  title: String!
  updatedAt: DateTime
  viewCount: Int
}

input PostCreateWithoutCommentsInput {
  author: UserCreateOneWithoutPostsInput
  content: String
  createdAt: DateTime
  published: Boolean
  title: String!
  updatedAt: DateTime
  viewCount: Int
}

input PostListRelationFilter {
  every: PostWhereInput
  none: PostWhereInput
  some: PostWhereInput
}

input PostOrderByInput {
  authorId: SortOrder
  content: SortOrder
  createdAt: SortOrder
  id: SortOrder
  published: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  viewCount: SortOrder
}

input PostScalarWhereInput {
  AND: [PostScalarWhereInput!]
  authorId: IntNullableFilter
  content: StringNullableFilter
  createdAt: DateTimeFilter
  id: IntFilter
  NOT: [PostScalarWhereInput!]
  OR: [PostScalarWhereInput!]
  published: BoolFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  viewCount: IntFilter
}

input PostUpdateInput {
  author: UserUpdateOneWithoutPostsInput
  comments: CommentUpdateManyWithoutPostInput
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  viewCount: IntFieldUpdateOperationsInput
}

input PostUpdateManyDataInput {
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  viewCount: IntFieldUpdateOperationsInput
}

input PostUpdateManyMutationInput {
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  viewCount: IntFieldUpdateOperationsInput
}

input PostUpdateManyWithoutAuthorInput {
  connect: [PostWhereUniqueInput!]
  create: [PostCreateWithoutAuthorInput!]
  delete: [PostWhereUniqueInput!]
  deleteMany: [PostScalarWhereInput!]
  disconnect: [PostWhereUniqueInput!]
  set: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [PostUpdateManyWithWhereNestedInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutAuthorInput!]
}

input PostUpdateManyWithWhereNestedInput {
  data: PostUpdateManyDataInput!
  where: PostScalarWhereInput!
}

input PostUpdateOneRequiredWithoutCommentsInput {
  connect: PostWhereUniqueInput
  create: PostCreateWithoutCommentsInput
  update: PostUpdateWithoutCommentsDataInput
  upsert: PostUpsertWithoutCommentsInput
}

input PostUpdateWithoutAuthorDataInput {
  comments: CommentUpdateManyWithoutPostInput
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  viewCount: IntFieldUpdateOperationsInput
}

input PostUpdateWithoutCommentsDataInput {
  author: UserUpdateOneWithoutPostsInput
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  viewCount: IntFieldUpdateOperationsInput
}

input PostUpdateWithWhereUniqueWithoutAuthorInput {
  data: PostUpdateWithoutAuthorDataInput!
  where: PostWhereUniqueInput!
}

input PostUpsertWithoutCommentsInput {
  create: PostCreateWithoutCommentsInput!
  update: PostUpdateWithoutCommentsDataInput!
}

input PostUpsertWithWhereUniqueWithoutAuthorInput {
  create: PostCreateWithoutAuthorInput!
  update: PostUpdateWithoutAuthorDataInput!
  where: PostWhereUniqueInput!
}

input PostWhereInput {
  AND: [PostWhereInput!]
  author: UserWhereInput
  authorId: IntNullableFilter
  comments: CommentListRelationFilter
  content: StringNullableFilter
  createdAt: DateTimeFilter
  id: IntFilter
  NOT: [PostWhereInput!]
  OR: [PostWhereInput!]
  published: BoolFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  viewCount: IntFilter
}

input PostWhereUniqueInput {
  id: Int
}

type Query {
  comments(after: CommentWhereUniqueInput, before: CommentWhereUniqueInput, first: Int, last: Int, orderBy: [CommentOrderByInput!], where: CommentWhereInput): [Comment!]!
  findManyComment(cursor: CommentWhereUniqueInput, orderBy: CommentOrderByInput, skip: Int, take: Int, where: CommentWhereInput): [Comment]
  findManyCommentCount(cursor: CommentWhereUniqueInput, orderBy: CommentOrderByInput, skip: Int, take: Int, where: CommentWhereInput): Int
  findManyPost(cursor: PostWhereUniqueInput, orderBy: PostOrderByInput, skip: Int, take: Int, where: PostWhereInput): [Post]
  findManyPostCount(cursor: PostWhereUniqueInput, orderBy: PostOrderByInput, skip: Int, take: Int, where: PostWhereInput): Int
  findManyUser(cursor: UserWhereUniqueInput, orderBy: UserOrderByInput, skip: Int, take: Int, where: UserWhereInput): [User]
  findManyUserCount(cursor: UserWhereUniqueInput, orderBy: UserOrderByInput, skip: Int, take: Int, where: UserWhereInput): Int
  findOneComment(where: CommentWhereUniqueInput!): Comment
  findOnePost(where: PostWhereUniqueInput!): Post
  findOneUser(where: UserWhereUniqueInput!): User

  """The current authenticated User"""
  me: User
  posts(after: PostWhereUniqueInput, before: PostWhereUniqueInput, first: Int, last: Int, orderBy: [PostOrderByInput!], where: PostWhereInput): [Post!]!
  users(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int, orderBy: [UserOrderByInput!], where: UserWhereInput): [User!]!
}

enum QueryMode {
  default
  insensitive
}

enum Role {
  ADMIN
  SUPER_USER
  USER
}

"""User Role"""
enum RoleEnum {
  ADMIN
  SUPER_USER
  USER
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

"""A user registered with the application"""
type User {
  comments(cursor: CommentWhereUniqueInput, orderBy: CommentOrderByInput, skip: Int, take: Int, where: CommentWhereInput): [Comment!]!
  createdAt: DateTime!
  email: String!
  fullName: String
  id: Int!
  isDeleted: Boolean!
  name: String!
  password: String!
  posts(cursor: PostWhereUniqueInput, orderBy: PostOrderByInput, skip: Int, take: Int, where: PostWhereInput): [Post!]!
  role: RoleEnum
  surname: String!
}

input UserCreateInput {
  comments: CommentCreateManyWithoutAuthorInput
  createdAt: DateTime
  email: String!
  isDeleted: Boolean
  name: String!
  password: String!
  posts: PostCreateManyWithoutAuthorInput
  role: Role
  surname: String!
}

input UserCreateOneWithoutCommentsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutCommentsInput
}

input UserCreateOneWithoutPostsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutPostsInput
}

input UserCreateWithoutCommentsInput {
  createdAt: DateTime
  email: String!
  isDeleted: Boolean
  name: String!
  password: String!
  posts: PostCreateManyWithoutAuthorInput
  role: Role
  surname: String!
}

input UserCreateWithoutPostsInput {
  comments: CommentCreateManyWithoutAuthorInput
  createdAt: DateTime
  email: String!
  isDeleted: Boolean
  name: String!
  password: String!
  role: Role
  surname: String!
}

input UserOrderByInput {
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  isDeleted: SortOrder
  name: SortOrder
  password: SortOrder
  role: SortOrder
  surname: SortOrder
}

input UserUpdateInput {
  comments: CommentUpdateManyWithoutAuthorInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  isDeleted: BoolFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  posts: PostUpdateManyWithoutAuthorInput
  role: EnumRoleFieldUpdateOperationsInput
  surname: StringFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  isDeleted: BoolFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  surname: StringFieldUpdateOperationsInput
}

input UserUpdateOneWithoutCommentsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutCommentsInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutCommentsDataInput
  upsert: UserUpsertWithoutCommentsInput
}

input UserUpdateOneWithoutPostsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutPostsInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutPostsDataInput
  upsert: UserUpsertWithoutPostsInput
}

input UserUpdateWithoutCommentsDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  isDeleted: BoolFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  posts: PostUpdateManyWithoutAuthorInput
  role: EnumRoleFieldUpdateOperationsInput
  surname: StringFieldUpdateOperationsInput
}

input UserUpdateWithoutPostsDataInput {
  comments: CommentUpdateManyWithoutAuthorInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  isDeleted: BoolFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  surname: StringFieldUpdateOperationsInput
}

input UserUpsertWithoutCommentsInput {
  create: UserCreateWithoutCommentsInput!
  update: UserUpdateWithoutCommentsDataInput!
}

input UserUpsertWithoutPostsInput {
  create: UserCreateWithoutPostsInput!
  update: UserUpdateWithoutPostsDataInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  comments: CommentListRelationFilter
  createdAt: DateTimeFilter
  email: StringFilter
  id: IntFilter
  isDeleted: BoolFilter
  name: StringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: StringFilter
  posts: PostListRelationFilter
  role: EnumRoleFilter
  surname: StringFilter
}

input UserWhereUniqueInput {
  email: String
  id: Int
}
